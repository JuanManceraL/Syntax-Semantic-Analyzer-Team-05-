Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> statements
Rule 1     statements -> statements statement
Rule 2     statements -> statement
Rule 3     statements -> <empty>
Rule 4     statement -> declaration
Rule 5     statement -> assignment
Rule 6     statement -> prt
Rule 7     statement -> directives
Rule 8     statement -> ifst
Rule 9     directives -> NS DIRECTIVES LIBRARIES
Rule 10    declaration -> TYPE IDENTIFIER SEMIC
Rule 11    declaration -> TYPE IDENTIFIER EQUALS expression SEMIC
Rule 12    assignment -> IDENTIFIER EQUALS expression SEMIC
Rule 13    prt -> PRINT LPAREN expression RPAREN SEMIC
Rule 14    ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB
Rule 15    ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB
Rule 16    expression -> expression PLUS term
Rule 17    expression -> expression MINUS term
Rule 18    term -> term TIMES factor
Rule 19    term -> term DIVIDE factor
Rule 20    factor -> EXP LPAREN factor value RPAREN
Rule 21    factor -> SQR LPAREN factor RPAREN
Rule 22    value -> NUMBER
Rule 23    valbool -> VAL_BOOL
Rule 24    valbool -> LPAREN valbool RPAREN
Rule 25    valbool -> expression OP_BOOL expression
Rule 26    expression -> term
Rule 27    term -> factor
Rule 28    factor -> value
Rule 29    factor -> IDENTIFIER
Rule 30    factor -> LPAREN expression RPAREN
Rule 31    factor -> MINUS factor

Terminals, with rules where they appear

CCURLB               : 14 15 15
DIRECTIVES           : 9
DIVIDE               : 19
ELSE                 : 15
EQUALS               : 11 12
EXP                  : 20
IDENTIFIER           : 10 11 12 29
IF                   : 14 15
LIBRARIES            : 9
LPAREN               : 13 14 15 20 21 24 30
MINUS                : 17 31
NS                   : 9
NUMBER               : 22
OCURLB               : 14 15 15
OP_BOOL              : 25
PLUS                 : 16
PRINT                : 13
RPAREN               : 13 14 15 20 21 24 30
SEMIC                : 10 11 12 13
SQR                  : 21
TIMES                : 18
TYPE                 : 10 11
VAL_BOOL             : 23
error                : 

Nonterminals, with rules where they appear

assignment           : 5
declaration          : 4
directives           : 7
expression           : 11 12 13 16 17 25 25 30
factor               : 18 19 20 21 27 31
ifst                 : 8
prt                  : 6
statement            : 1 2
statements           : 1 14 15 15 0
term                 : 16 17 18 19 26
valbool              : 14 15 24
value                : 20 28

Parsing method: LALR

state 0

    (0) S' -> . statements
    (1) statements -> . statements statement
    (2) statements -> . statement
    (3) statements -> .
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . prt
    (7) statement -> . directives
    (8) statement -> . ifst
    (10) declaration -> . TYPE IDENTIFIER SEMIC
    (11) declaration -> . TYPE IDENTIFIER EQUALS expression SEMIC
    (12) assignment -> . IDENTIFIER EQUALS expression SEMIC
    (13) prt -> . PRINT LPAREN expression RPAREN SEMIC
    (9) directives -> . NS DIRECTIVES LIBRARIES
    (14) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB
    (15) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NS resolved as shift
  ! shift/reduce conflict for IF resolved as shift
    $end            reduce using rule 3 (statements -> .)
    TYPE            shift and go to state 8
    IDENTIFIER      shift and go to state 9
    PRINT           shift and go to state 10
    NS              shift and go to state 11
    IF              shift and go to state 12

  ! TYPE            [ reduce using rule 3 (statements -> .) ]
  ! IDENTIFIER      [ reduce using rule 3 (statements -> .) ]
  ! PRINT           [ reduce using rule 3 (statements -> .) ]
  ! NS              [ reduce using rule 3 (statements -> .) ]
  ! IF              [ reduce using rule 3 (statements -> .) ]

    statements                     shift and go to state 1
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    prt                            shift and go to state 5
    directives                     shift and go to state 6
    ifst                           shift and go to state 7

state 1

    (0) S' -> statements .
    (1) statements -> statements . statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . prt
    (7) statement -> . directives
    (8) statement -> . ifst
    (10) declaration -> . TYPE IDENTIFIER SEMIC
    (11) declaration -> . TYPE IDENTIFIER EQUALS expression SEMIC
    (12) assignment -> . IDENTIFIER EQUALS expression SEMIC
    (13) prt -> . PRINT LPAREN expression RPAREN SEMIC
    (9) directives -> . NS DIRECTIVES LIBRARIES
    (14) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB
    (15) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB

    TYPE            shift and go to state 8
    IDENTIFIER      shift and go to state 9
    PRINT           shift and go to state 10
    NS              shift and go to state 11
    IF              shift and go to state 12

    statement                      shift and go to state 13
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    prt                            shift and go to state 5
    directives                     shift and go to state 6
    ifst                           shift and go to state 7

state 2

    (2) statements -> statement .

    TYPE            reduce using rule 2 (statements -> statement .)
    IDENTIFIER      reduce using rule 2 (statements -> statement .)
    PRINT           reduce using rule 2 (statements -> statement .)
    NS              reduce using rule 2 (statements -> statement .)
    IF              reduce using rule 2 (statements -> statement .)
    $end            reduce using rule 2 (statements -> statement .)
    CCURLB          reduce using rule 2 (statements -> statement .)


state 3

    (4) statement -> declaration .

    TYPE            reduce using rule 4 (statement -> declaration .)
    IDENTIFIER      reduce using rule 4 (statement -> declaration .)
    PRINT           reduce using rule 4 (statement -> declaration .)
    NS              reduce using rule 4 (statement -> declaration .)
    IF              reduce using rule 4 (statement -> declaration .)
    $end            reduce using rule 4 (statement -> declaration .)
    CCURLB          reduce using rule 4 (statement -> declaration .)


state 4

    (5) statement -> assignment .

    TYPE            reduce using rule 5 (statement -> assignment .)
    IDENTIFIER      reduce using rule 5 (statement -> assignment .)
    PRINT           reduce using rule 5 (statement -> assignment .)
    NS              reduce using rule 5 (statement -> assignment .)
    IF              reduce using rule 5 (statement -> assignment .)
    $end            reduce using rule 5 (statement -> assignment .)
    CCURLB          reduce using rule 5 (statement -> assignment .)


state 5

    (6) statement -> prt .

    TYPE            reduce using rule 6 (statement -> prt .)
    IDENTIFIER      reduce using rule 6 (statement -> prt .)
    PRINT           reduce using rule 6 (statement -> prt .)
    NS              reduce using rule 6 (statement -> prt .)
    IF              reduce using rule 6 (statement -> prt .)
    $end            reduce using rule 6 (statement -> prt .)
    CCURLB          reduce using rule 6 (statement -> prt .)


state 6

    (7) statement -> directives .

    TYPE            reduce using rule 7 (statement -> directives .)
    IDENTIFIER      reduce using rule 7 (statement -> directives .)
    PRINT           reduce using rule 7 (statement -> directives .)
    NS              reduce using rule 7 (statement -> directives .)
    IF              reduce using rule 7 (statement -> directives .)
    $end            reduce using rule 7 (statement -> directives .)
    CCURLB          reduce using rule 7 (statement -> directives .)


state 7

    (8) statement -> ifst .

    TYPE            reduce using rule 8 (statement -> ifst .)
    IDENTIFIER      reduce using rule 8 (statement -> ifst .)
    PRINT           reduce using rule 8 (statement -> ifst .)
    NS              reduce using rule 8 (statement -> ifst .)
    IF              reduce using rule 8 (statement -> ifst .)
    $end            reduce using rule 8 (statement -> ifst .)
    CCURLB          reduce using rule 8 (statement -> ifst .)


state 8

    (10) declaration -> TYPE . IDENTIFIER SEMIC
    (11) declaration -> TYPE . IDENTIFIER EQUALS expression SEMIC

    IDENTIFIER      shift and go to state 14


state 9

    (12) assignment -> IDENTIFIER . EQUALS expression SEMIC

    EQUALS          shift and go to state 15


state 10

    (13) prt -> PRINT . LPAREN expression RPAREN SEMIC

    LPAREN          shift and go to state 16


state 11

    (9) directives -> NS . DIRECTIVES LIBRARIES

    DIRECTIVES      shift and go to state 17


state 12

    (14) ifst -> IF . LPAREN valbool RPAREN OCURLB statements CCURLB
    (15) ifst -> IF . LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB

    LPAREN          shift and go to state 18


state 13

    (1) statements -> statements statement .

    TYPE            reduce using rule 1 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 1 (statements -> statements statement .)
    PRINT           reduce using rule 1 (statements -> statements statement .)
    NS              reduce using rule 1 (statements -> statements statement .)
    IF              reduce using rule 1 (statements -> statements statement .)
    $end            reduce using rule 1 (statements -> statements statement .)
    CCURLB          reduce using rule 1 (statements -> statements statement .)


state 14

    (10) declaration -> TYPE IDENTIFIER . SEMIC
    (11) declaration -> TYPE IDENTIFIER . EQUALS expression SEMIC

    SEMIC           shift and go to state 19
    EQUALS          shift and go to state 20


state 15

    (12) assignment -> IDENTIFIER EQUALS . expression SEMIC
    (16) expression -> . expression PLUS term
    (17) expression -> . expression MINUS term
    (26) expression -> . term
    (18) term -> . term TIMES factor
    (19) term -> . term DIVIDE factor
    (27) term -> . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    expression                     shift and go to state 22
    term                           shift and go to state 23
    factor                         shift and go to state 25
    value                          shift and go to state 28

state 16

    (13) prt -> PRINT LPAREN . expression RPAREN SEMIC
    (16) expression -> . expression PLUS term
    (17) expression -> . expression MINUS term
    (26) expression -> . term
    (18) term -> . term TIMES factor
    (19) term -> . term DIVIDE factor
    (27) term -> . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    expression                     shift and go to state 31
    term                           shift and go to state 23
    factor                         shift and go to state 25
    value                          shift and go to state 28

state 17

    (9) directives -> NS DIRECTIVES . LIBRARIES

    LIBRARIES       shift and go to state 32


state 18

    (14) ifst -> IF LPAREN . valbool RPAREN OCURLB statements CCURLB
    (15) ifst -> IF LPAREN . valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB
    (23) valbool -> . VAL_BOOL
    (24) valbool -> . LPAREN valbool RPAREN
    (25) valbool -> . expression OP_BOOL expression
    (16) expression -> . expression PLUS term
    (17) expression -> . expression MINUS term
    (26) expression -> . term
    (18) term -> . term TIMES factor
    (19) term -> . term DIVIDE factor
    (27) term -> . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    VAL_BOOL        shift and go to state 35
    LPAREN          shift and go to state 33
    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    valbool                        shift and go to state 34
    expression                     shift and go to state 36
    term                           shift and go to state 23
    factor                         shift and go to state 25
    value                          shift and go to state 28

state 19

    (10) declaration -> TYPE IDENTIFIER SEMIC .

    TYPE            reduce using rule 10 (declaration -> TYPE IDENTIFIER SEMIC .)
    IDENTIFIER      reduce using rule 10 (declaration -> TYPE IDENTIFIER SEMIC .)
    PRINT           reduce using rule 10 (declaration -> TYPE IDENTIFIER SEMIC .)
    NS              reduce using rule 10 (declaration -> TYPE IDENTIFIER SEMIC .)
    IF              reduce using rule 10 (declaration -> TYPE IDENTIFIER SEMIC .)
    $end            reduce using rule 10 (declaration -> TYPE IDENTIFIER SEMIC .)
    CCURLB          reduce using rule 10 (declaration -> TYPE IDENTIFIER SEMIC .)


state 20

    (11) declaration -> TYPE IDENTIFIER EQUALS . expression SEMIC
    (16) expression -> . expression PLUS term
    (17) expression -> . expression MINUS term
    (26) expression -> . term
    (18) term -> . term TIMES factor
    (19) term -> . term DIVIDE factor
    (27) term -> . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    expression                     shift and go to state 37
    term                           shift and go to state 23
    factor                         shift and go to state 25
    value                          shift and go to state 28

state 21

    (29) factor -> IDENTIFIER .

    TIMES           reduce using rule 29 (factor -> IDENTIFIER .)
    DIVIDE          reduce using rule 29 (factor -> IDENTIFIER .)
    SEMIC           reduce using rule 29 (factor -> IDENTIFIER .)
    PLUS            reduce using rule 29 (factor -> IDENTIFIER .)
    MINUS           reduce using rule 29 (factor -> IDENTIFIER .)
    RPAREN          reduce using rule 29 (factor -> IDENTIFIER .)
    OP_BOOL         reduce using rule 29 (factor -> IDENTIFIER .)
    NUMBER          reduce using rule 29 (factor -> IDENTIFIER .)


state 22

    (12) assignment -> IDENTIFIER EQUALS expression . SEMIC
    (16) expression -> expression . PLUS term
    (17) expression -> expression . MINUS term

    SEMIC           shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 23

    (26) expression -> term .
    (18) term -> term . TIMES factor
    (19) term -> term . DIVIDE factor

    SEMIC           reduce using rule 26 (expression -> term .)
    PLUS            reduce using rule 26 (expression -> term .)
    MINUS           reduce using rule 26 (expression -> term .)
    RPAREN          reduce using rule 26 (expression -> term .)
    OP_BOOL         reduce using rule 26 (expression -> term .)
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42


state 24

    (31) factor -> MINUS . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    factor                         shift and go to state 43
    value                          shift and go to state 28

state 25

    (27) term -> factor .

    TIMES           reduce using rule 27 (term -> factor .)
    DIVIDE          reduce using rule 27 (term -> factor .)
    SEMIC           reduce using rule 27 (term -> factor .)
    PLUS            reduce using rule 27 (term -> factor .)
    MINUS           reduce using rule 27 (term -> factor .)
    RPAREN          reduce using rule 27 (term -> factor .)
    OP_BOOL         reduce using rule 27 (term -> factor .)


state 26

    (20) factor -> EXP . LPAREN factor value RPAREN

    LPAREN          shift and go to state 44


state 27

    (30) factor -> LPAREN . expression RPAREN
    (16) expression -> . expression PLUS term
    (17) expression -> . expression MINUS term
    (26) expression -> . term
    (18) term -> . term TIMES factor
    (19) term -> . term DIVIDE factor
    (27) term -> . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    expression                     shift and go to state 45
    term                           shift and go to state 23
    factor                         shift and go to state 25
    value                          shift and go to state 28

state 28

    (28) factor -> value .

    TIMES           reduce using rule 28 (factor -> value .)
    DIVIDE          reduce using rule 28 (factor -> value .)
    SEMIC           reduce using rule 28 (factor -> value .)
    PLUS            reduce using rule 28 (factor -> value .)
    MINUS           reduce using rule 28 (factor -> value .)
    RPAREN          reduce using rule 28 (factor -> value .)
    OP_BOOL         reduce using rule 28 (factor -> value .)
    NUMBER          reduce using rule 28 (factor -> value .)


state 29

    (21) factor -> SQR . LPAREN factor RPAREN

    LPAREN          shift and go to state 46


state 30

    (22) value -> NUMBER .

    TIMES           reduce using rule 22 (value -> NUMBER .)
    DIVIDE          reduce using rule 22 (value -> NUMBER .)
    SEMIC           reduce using rule 22 (value -> NUMBER .)
    PLUS            reduce using rule 22 (value -> NUMBER .)
    MINUS           reduce using rule 22 (value -> NUMBER .)
    RPAREN          reduce using rule 22 (value -> NUMBER .)
    OP_BOOL         reduce using rule 22 (value -> NUMBER .)
    NUMBER          reduce using rule 22 (value -> NUMBER .)


state 31

    (13) prt -> PRINT LPAREN expression . RPAREN SEMIC
    (16) expression -> expression . PLUS term
    (17) expression -> expression . MINUS term

    RPAREN          shift and go to state 47
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 32

    (9) directives -> NS DIRECTIVES LIBRARIES .

    TYPE            reduce using rule 9 (directives -> NS DIRECTIVES LIBRARIES .)
    IDENTIFIER      reduce using rule 9 (directives -> NS DIRECTIVES LIBRARIES .)
    PRINT           reduce using rule 9 (directives -> NS DIRECTIVES LIBRARIES .)
    NS              reduce using rule 9 (directives -> NS DIRECTIVES LIBRARIES .)
    IF              reduce using rule 9 (directives -> NS DIRECTIVES LIBRARIES .)
    $end            reduce using rule 9 (directives -> NS DIRECTIVES LIBRARIES .)
    CCURLB          reduce using rule 9 (directives -> NS DIRECTIVES LIBRARIES .)


state 33

    (24) valbool -> LPAREN . valbool RPAREN
    (30) factor -> LPAREN . expression RPAREN
    (23) valbool -> . VAL_BOOL
    (24) valbool -> . LPAREN valbool RPAREN
    (25) valbool -> . expression OP_BOOL expression
    (16) expression -> . expression PLUS term
    (17) expression -> . expression MINUS term
    (26) expression -> . term
    (18) term -> . term TIMES factor
    (19) term -> . term DIVIDE factor
    (27) term -> . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    VAL_BOOL        shift and go to state 35
    LPAREN          shift and go to state 33
    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    valbool                        shift and go to state 48
    expression                     shift and go to state 49
    term                           shift and go to state 23
    factor                         shift and go to state 25
    value                          shift and go to state 28

state 34

    (14) ifst -> IF LPAREN valbool . RPAREN OCURLB statements CCURLB
    (15) ifst -> IF LPAREN valbool . RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB

    RPAREN          shift and go to state 50


state 35

    (23) valbool -> VAL_BOOL .

    RPAREN          reduce using rule 23 (valbool -> VAL_BOOL .)


state 36

    (25) valbool -> expression . OP_BOOL expression
    (16) expression -> expression . PLUS term
    (17) expression -> expression . MINUS term

    OP_BOOL         shift and go to state 51
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 37

    (11) declaration -> TYPE IDENTIFIER EQUALS expression . SEMIC
    (16) expression -> expression . PLUS term
    (17) expression -> expression . MINUS term

    SEMIC           shift and go to state 52
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 38

    (12) assignment -> IDENTIFIER EQUALS expression SEMIC .

    TYPE            reduce using rule 12 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    IDENTIFIER      reduce using rule 12 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    PRINT           reduce using rule 12 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    NS              reduce using rule 12 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    IF              reduce using rule 12 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    $end            reduce using rule 12 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    CCURLB          reduce using rule 12 (assignment -> IDENTIFIER EQUALS expression SEMIC .)


state 39

    (16) expression -> expression PLUS . term
    (18) term -> . term TIMES factor
    (19) term -> . term DIVIDE factor
    (27) term -> . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    term                           shift and go to state 53
    factor                         shift and go to state 25
    value                          shift and go to state 28

state 40

    (17) expression -> expression MINUS . term
    (18) term -> . term TIMES factor
    (19) term -> . term DIVIDE factor
    (27) term -> . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    term                           shift and go to state 54
    factor                         shift and go to state 25
    value                          shift and go to state 28

state 41

    (18) term -> term TIMES . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    factor                         shift and go to state 55
    value                          shift and go to state 28

state 42

    (19) term -> term DIVIDE . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    factor                         shift and go to state 56
    value                          shift and go to state 28

state 43

    (31) factor -> MINUS factor .

    TIMES           reduce using rule 31 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 31 (factor -> MINUS factor .)
    SEMIC           reduce using rule 31 (factor -> MINUS factor .)
    PLUS            reduce using rule 31 (factor -> MINUS factor .)
    MINUS           reduce using rule 31 (factor -> MINUS factor .)
    RPAREN          reduce using rule 31 (factor -> MINUS factor .)
    OP_BOOL         reduce using rule 31 (factor -> MINUS factor .)
    NUMBER          reduce using rule 31 (factor -> MINUS factor .)


state 44

    (20) factor -> EXP LPAREN . factor value RPAREN
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    factor                         shift and go to state 57
    value                          shift and go to state 28

state 45

    (30) factor -> LPAREN expression . RPAREN
    (16) expression -> expression . PLUS term
    (17) expression -> expression . MINUS term

    RPAREN          shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 46

    (21) factor -> SQR LPAREN . factor RPAREN
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    factor                         shift and go to state 59
    value                          shift and go to state 28

state 47

    (13) prt -> PRINT LPAREN expression RPAREN . SEMIC

    SEMIC           shift and go to state 60


state 48

    (24) valbool -> LPAREN valbool . RPAREN

    RPAREN          shift and go to state 61


state 49

    (30) factor -> LPAREN expression . RPAREN
    (25) valbool -> expression . OP_BOOL expression
    (16) expression -> expression . PLUS term
    (17) expression -> expression . MINUS term

    RPAREN          shift and go to state 58
    OP_BOOL         shift and go to state 51
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 50

    (14) ifst -> IF LPAREN valbool RPAREN . OCURLB statements CCURLB
    (15) ifst -> IF LPAREN valbool RPAREN . OCURLB statements CCURLB ELSE OCURLB statements CCURLB

    OCURLB          shift and go to state 62


state 51

    (25) valbool -> expression OP_BOOL . expression
    (16) expression -> . expression PLUS term
    (17) expression -> . expression MINUS term
    (26) expression -> . term
    (18) term -> . term TIMES factor
    (19) term -> . term DIVIDE factor
    (27) term -> . factor
    (20) factor -> . EXP LPAREN factor value RPAREN
    (21) factor -> . SQR LPAREN factor RPAREN
    (28) factor -> . value
    (29) factor -> . IDENTIFIER
    (30) factor -> . LPAREN expression RPAREN
    (31) factor -> . MINUS factor
    (22) value -> . NUMBER

    EXP             shift and go to state 26
    SQR             shift and go to state 29
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 27
    MINUS           shift and go to state 24
    NUMBER          shift and go to state 30

    expression                     shift and go to state 63
    term                           shift and go to state 23
    factor                         shift and go to state 25
    value                          shift and go to state 28

state 52

    (11) declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .

    TYPE            reduce using rule 11 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    IDENTIFIER      reduce using rule 11 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    PRINT           reduce using rule 11 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    NS              reduce using rule 11 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    IF              reduce using rule 11 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    $end            reduce using rule 11 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    CCURLB          reduce using rule 11 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)


state 53

    (16) expression -> expression PLUS term .
    (18) term -> term . TIMES factor
    (19) term -> term . DIVIDE factor

    SEMIC           reduce using rule 16 (expression -> expression PLUS term .)
    PLUS            reduce using rule 16 (expression -> expression PLUS term .)
    MINUS           reduce using rule 16 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 16 (expression -> expression PLUS term .)
    OP_BOOL         reduce using rule 16 (expression -> expression PLUS term .)
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42


state 54

    (17) expression -> expression MINUS term .
    (18) term -> term . TIMES factor
    (19) term -> term . DIVIDE factor

    SEMIC           reduce using rule 17 (expression -> expression MINUS term .)
    PLUS            reduce using rule 17 (expression -> expression MINUS term .)
    MINUS           reduce using rule 17 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 17 (expression -> expression MINUS term .)
    OP_BOOL         reduce using rule 17 (expression -> expression MINUS term .)
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42


state 55

    (18) term -> term TIMES factor .

    TIMES           reduce using rule 18 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 18 (term -> term TIMES factor .)
    SEMIC           reduce using rule 18 (term -> term TIMES factor .)
    PLUS            reduce using rule 18 (term -> term TIMES factor .)
    MINUS           reduce using rule 18 (term -> term TIMES factor .)
    RPAREN          reduce using rule 18 (term -> term TIMES factor .)
    OP_BOOL         reduce using rule 18 (term -> term TIMES factor .)


state 56

    (19) term -> term DIVIDE factor .

    TIMES           reduce using rule 19 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 19 (term -> term DIVIDE factor .)
    SEMIC           reduce using rule 19 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 19 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 19 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 19 (term -> term DIVIDE factor .)
    OP_BOOL         reduce using rule 19 (term -> term DIVIDE factor .)


state 57

    (20) factor -> EXP LPAREN factor . value RPAREN
    (22) value -> . NUMBER

    NUMBER          shift and go to state 30

    value                          shift and go to state 64

state 58

    (30) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 30 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 30 (factor -> LPAREN expression RPAREN .)
    SEMIC           reduce using rule 30 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 30 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 30 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 30 (factor -> LPAREN expression RPAREN .)
    OP_BOOL         reduce using rule 30 (factor -> LPAREN expression RPAREN .)
    NUMBER          reduce using rule 30 (factor -> LPAREN expression RPAREN .)


state 59

    (21) factor -> SQR LPAREN factor . RPAREN

    RPAREN          shift and go to state 65


state 60

    (13) prt -> PRINT LPAREN expression RPAREN SEMIC .

    TYPE            reduce using rule 13 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    IDENTIFIER      reduce using rule 13 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    PRINT           reduce using rule 13 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    NS              reduce using rule 13 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    IF              reduce using rule 13 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    $end            reduce using rule 13 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    CCURLB          reduce using rule 13 (prt -> PRINT LPAREN expression RPAREN SEMIC .)


state 61

    (24) valbool -> LPAREN valbool RPAREN .

    RPAREN          reduce using rule 24 (valbool -> LPAREN valbool RPAREN .)


state 62

    (14) ifst -> IF LPAREN valbool RPAREN OCURLB . statements CCURLB
    (15) ifst -> IF LPAREN valbool RPAREN OCURLB . statements CCURLB ELSE OCURLB statements CCURLB
    (1) statements -> . statements statement
    (2) statements -> . statement
    (3) statements -> .
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . prt
    (7) statement -> . directives
    (8) statement -> . ifst
    (10) declaration -> . TYPE IDENTIFIER SEMIC
    (11) declaration -> . TYPE IDENTIFIER EQUALS expression SEMIC
    (12) assignment -> . IDENTIFIER EQUALS expression SEMIC
    (13) prt -> . PRINT LPAREN expression RPAREN SEMIC
    (9) directives -> . NS DIRECTIVES LIBRARIES
    (14) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB
    (15) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NS resolved as shift
  ! shift/reduce conflict for IF resolved as shift
    CCURLB          reduce using rule 3 (statements -> .)
    TYPE            shift and go to state 8
    IDENTIFIER      shift and go to state 9
    PRINT           shift and go to state 10
    NS              shift and go to state 11
    IF              shift and go to state 12

  ! TYPE            [ reduce using rule 3 (statements -> .) ]
  ! IDENTIFIER      [ reduce using rule 3 (statements -> .) ]
  ! PRINT           [ reduce using rule 3 (statements -> .) ]
  ! NS              [ reduce using rule 3 (statements -> .) ]
  ! IF              [ reduce using rule 3 (statements -> .) ]

    statements                     shift and go to state 66
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    prt                            shift and go to state 5
    directives                     shift and go to state 6
    ifst                           shift and go to state 7

state 63

    (25) valbool -> expression OP_BOOL expression .
    (16) expression -> expression . PLUS term
    (17) expression -> expression . MINUS term

    RPAREN          reduce using rule 25 (valbool -> expression OP_BOOL expression .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 64

    (20) factor -> EXP LPAREN factor value . RPAREN

    RPAREN          shift and go to state 67


state 65

    (21) factor -> SQR LPAREN factor RPAREN .

    TIMES           reduce using rule 21 (factor -> SQR LPAREN factor RPAREN .)
    DIVIDE          reduce using rule 21 (factor -> SQR LPAREN factor RPAREN .)
    SEMIC           reduce using rule 21 (factor -> SQR LPAREN factor RPAREN .)
    PLUS            reduce using rule 21 (factor -> SQR LPAREN factor RPAREN .)
    MINUS           reduce using rule 21 (factor -> SQR LPAREN factor RPAREN .)
    RPAREN          reduce using rule 21 (factor -> SQR LPAREN factor RPAREN .)
    OP_BOOL         reduce using rule 21 (factor -> SQR LPAREN factor RPAREN .)
    NUMBER          reduce using rule 21 (factor -> SQR LPAREN factor RPAREN .)


state 66

    (14) ifst -> IF LPAREN valbool RPAREN OCURLB statements . CCURLB
    (15) ifst -> IF LPAREN valbool RPAREN OCURLB statements . CCURLB ELSE OCURLB statements CCURLB
    (1) statements -> statements . statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . prt
    (7) statement -> . directives
    (8) statement -> . ifst
    (10) declaration -> . TYPE IDENTIFIER SEMIC
    (11) declaration -> . TYPE IDENTIFIER EQUALS expression SEMIC
    (12) assignment -> . IDENTIFIER EQUALS expression SEMIC
    (13) prt -> . PRINT LPAREN expression RPAREN SEMIC
    (9) directives -> . NS DIRECTIVES LIBRARIES
    (14) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB
    (15) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB

    CCURLB          shift and go to state 68
    TYPE            shift and go to state 8
    IDENTIFIER      shift and go to state 9
    PRINT           shift and go to state 10
    NS              shift and go to state 11
    IF              shift and go to state 12

    statement                      shift and go to state 13
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    prt                            shift and go to state 5
    directives                     shift and go to state 6
    ifst                           shift and go to state 7

state 67

    (20) factor -> EXP LPAREN factor value RPAREN .

    TIMES           reduce using rule 20 (factor -> EXP LPAREN factor value RPAREN .)
    DIVIDE          reduce using rule 20 (factor -> EXP LPAREN factor value RPAREN .)
    SEMIC           reduce using rule 20 (factor -> EXP LPAREN factor value RPAREN .)
    PLUS            reduce using rule 20 (factor -> EXP LPAREN factor value RPAREN .)
    MINUS           reduce using rule 20 (factor -> EXP LPAREN factor value RPAREN .)
    RPAREN          reduce using rule 20 (factor -> EXP LPAREN factor value RPAREN .)
    OP_BOOL         reduce using rule 20 (factor -> EXP LPAREN factor value RPAREN .)
    NUMBER          reduce using rule 20 (factor -> EXP LPAREN factor value RPAREN .)


state 68

    (14) ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB .
    (15) ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB . ELSE OCURLB statements CCURLB

    TYPE            reduce using rule 14 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB .)
    IDENTIFIER      reduce using rule 14 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB .)
    PRINT           reduce using rule 14 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB .)
    NS              reduce using rule 14 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB .)
    IF              reduce using rule 14 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB .)
    $end            reduce using rule 14 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB .)
    CCURLB          reduce using rule 14 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB .)
    ELSE            shift and go to state 69


state 69

    (15) ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE . OCURLB statements CCURLB

    OCURLB          shift and go to state 70


state 70

    (15) ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB . statements CCURLB
    (1) statements -> . statements statement
    (2) statements -> . statement
    (3) statements -> .
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . prt
    (7) statement -> . directives
    (8) statement -> . ifst
    (10) declaration -> . TYPE IDENTIFIER SEMIC
    (11) declaration -> . TYPE IDENTIFIER EQUALS expression SEMIC
    (12) assignment -> . IDENTIFIER EQUALS expression SEMIC
    (13) prt -> . PRINT LPAREN expression RPAREN SEMIC
    (9) directives -> . NS DIRECTIVES LIBRARIES
    (14) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB
    (15) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NS resolved as shift
  ! shift/reduce conflict for IF resolved as shift
    CCURLB          reduce using rule 3 (statements -> .)
    TYPE            shift and go to state 8
    IDENTIFIER      shift and go to state 9
    PRINT           shift and go to state 10
    NS              shift and go to state 11
    IF              shift and go to state 12

  ! TYPE            [ reduce using rule 3 (statements -> .) ]
  ! IDENTIFIER      [ reduce using rule 3 (statements -> .) ]
  ! PRINT           [ reduce using rule 3 (statements -> .) ]
  ! NS              [ reduce using rule 3 (statements -> .) ]
  ! IF              [ reduce using rule 3 (statements -> .) ]

    statements                     shift and go to state 71
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    prt                            shift and go to state 5
    directives                     shift and go to state 6
    ifst                           shift and go to state 7

state 71

    (15) ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements . CCURLB
    (1) statements -> statements . statement
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . prt
    (7) statement -> . directives
    (8) statement -> . ifst
    (10) declaration -> . TYPE IDENTIFIER SEMIC
    (11) declaration -> . TYPE IDENTIFIER EQUALS expression SEMIC
    (12) assignment -> . IDENTIFIER EQUALS expression SEMIC
    (13) prt -> . PRINT LPAREN expression RPAREN SEMIC
    (9) directives -> . NS DIRECTIVES LIBRARIES
    (14) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB
    (15) ifst -> . IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB

    CCURLB          shift and go to state 72
    TYPE            shift and go to state 8
    IDENTIFIER      shift and go to state 9
    PRINT           shift and go to state 10
    NS              shift and go to state 11
    IF              shift and go to state 12

    statement                      shift and go to state 13
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    prt                            shift and go to state 5
    directives                     shift and go to state 6
    ifst                           shift and go to state 7

state 72

    (15) ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB .

    TYPE            reduce using rule 15 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB .)
    IDENTIFIER      reduce using rule 15 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB .)
    PRINT           reduce using rule 15 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB .)
    NS              reduce using rule 15 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB .)
    IF              reduce using rule 15 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB .)
    $end            reduce using rule 15 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB .)
    CCURLB          reduce using rule 15 (ifst -> IF LPAREN valbool RPAREN OCURLB statements CCURLB ELSE OCURLB statements CCURLB .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for NS in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 62 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 62 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 62 resolved as shift
WARNING: shift/reduce conflict for NS in state 62 resolved as shift
WARNING: shift/reduce conflict for IF in state 62 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 70 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 70 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 70 resolved as shift
WARNING: shift/reduce conflict for NS in state 70 resolved as shift
WARNING: shift/reduce conflict for IF in state 70 resolved as shift
